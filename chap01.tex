\chapter{Abstract Interpretation}

In this chapter we define some mathematical concepts useful for understanding the Abstract Interpretation.
The covered topics are partial orderings, lattices or galois connections.
More advanced topics connected with abstract interpretation were well covered by B.~Blanchet\cite{Blanchet:2002:AI},
so I would redirect the more curious readers to his article.


\section{Introductory Example} %=======================================================================================%

We start with a very simple example that shows the basic idea behind abstract interpretation.
I do not define the syntax of the program as I assume that it is mostly clear. % todo weird
Consider this very simple toy program:

\begin{verbatim}

    a = read_number()
    b = read_number()
    c = a + b
    d = a * b
    e = a * a
    f = a - b
    g = a / b

\end{verbatim}

Given the assumption that \verb|read_number()| returns one real number given by the user and does not fail, what can
we say about the content of the variables \verb|c|, \verb|d|, \verb|e|, \verb|f| and \verb|g|?
Not much, except the fact that \verb|e| is non-negative (it is a square) and the calculation of \verb|g| can fail
(due to division by zero).
We cannot even say whether the values will be greater or less than the inputs \verb|a| and \verb|b|.

This, of course, changes, when we introduce additional constraints on the inputs \verb|a| and \verb|b|.
Example of such constraints can be: \verb|Both a and b are positive|.
What can we say about the variables then?
\begin{itemize}
    \item \verb|c| is positive and greater then \verb|a| and \verb|b|
    \item \verb|d| is positive
    \item \verb|e| is positive
    \item \verb|f| is in the interval $(-b, a)$
    \item \verb|g| is positive and the computation will not fail
\end{itemize}

Notice that the approximation of \verb|d| and \verb|e| would be more precise if we also said whether the inputs
are greater or less than 1.

This shows that when we know the approximations of the input values, we are able to make statements about the behaviour
of the program.
In abstract interpretation, we try to interpret (execute) the given program with approximated input values and try to
prove that the output is in such bounds or that it does not crash in any (or some) case.
Such analysis is always correct, but the results are not precise - it is an approximation of the behaviour of the program.
Also note that this can be actually useful in practice since in many programs the variables usually are bounded due to
their semantics.
For example the hour of a day will always be a number between 0 and 24 (will you figure out why not just 23?),
number of workers in a factory will be always non-negative, election results of a political party will always be
between 0 and 100 and a sum of degrees of an undirected graph will always be an even number.

But what information should we remember for the variables in the program?
In the simplest case we can just remember whether the values are positive, negative or zero.
More advanced case (the one that we use in the example above) can use intervals.
Generally we use a unification of arbitrary disjunctive (for simplicity) sets.
Then the input constraints can look like this:
\[a \in {1, 2, 3} \cup (0, 1)\]
\[b \in \mathbb{R}\]

The idea of approximation of values with unification of sets of possible solutions can be applied to other subjects than
just real numbers.
Some examples:
\begin{itemize}
    \item Matrix operations can be approximated by dimensions of matrices and ensure that the operations
    (matrix addition, multiplication, gaussian elimination) are correct.

    \item Geometry in 2D (or higher dimensions).
    Points can be approximated by rectangular sectors.

    \item Boolean algebra

    \item Tabular data - the topic of this thesis
\end{itemize}


\section{Lattices} %===================================================================================================%

We first recall few already well-known definitions (Poset, Supremum, Infimum, Monotonous function) and then use this
to state the definitions of new objects (Lattice, Complete Lattice, Galois Connection).

\begin{defn}[Partial order]
    Relation $\leq$ on set $S$ is an partial order if $\forall a, b, c \in P$:
    \begin{enumerate}
        \item $a \leq a$ (Reflexivity)
        \item $a \leq b \land b \leq a \implies a = b$ (Antisymmetry)
        \item $a \leq b \land b \leq c \implies a \leq c$ (Transitivity)
    \end{enumerate}
\end{defn}

Then defining a partially ordered set (Poset) is straightforward:

\begin{defn}[Poset]
    The pair $(S, \leq)$ is a Poset, if $\leq$ is a partial order on $S$
\end{defn}

We also mention few examples of Poset:

\begin{itemize}
    \item $(\mathbb{R}, \leq), (\mathbb{Q}, \leq), (\mathbb{Z}, \leq)$ are all Posets
    \item For a set $S$, $(\mathbb{P}(S), \subseteq)$ is a Poset
    \item Non-negative integers with divisibility are a Poset
    \item For directed acyclic graph $G=(V,E)$ the pair $(V, reachability)$ is a Poset
\end{itemize}

\xxx{monotonous function}

Last thing that we need before defining a Lattice are the definitions of supremum and infimum.

\begin{defn}
    On partially ordered set $(S, \leq)$, for $R \subseteq S$:

    Upper bound of $R$ in $S$ is $a \in S$ such that $\forall x \in R: x \leq a$

    Lower bound of $R$ in $S$ is $a \in S$ such that $\forall x \in R: a \leq x$

    Supremum of $R$ in $S$ is $a \in S$ such that $a$ is a lower bound of $R$ %todo sup() inf() symbols

    Infimum of $R$ in $S$ is $a \in S$ such that
\end{defn}

With this knowledge, we have all we need to define a Lattice:
\begin{defn}[Lattice]
    A Poset $(L, \leq)$) is a Lattice if:
    \[\forall a, b \in L \: \exists s \in L: s = \sup(\{a,b\})\]
    \[\forall a, b \in L \: \exists u \in L: u = \inf(\{a,b\})\]
\end{defn}

\xxx{todo comment}

\begin{defn}[Complete Lattice]
    A Poset $(L, \leq)$ is a Complete Lattice if:
    \[\forall X \subseteq L \: \exists s \in L: s = \sup(X)\]
    \[\forall X \subseteq L \: \exists u \in L: u = \inf(X)\]
\end{defn}


\xxx{lattices}


\section{Program semantics} % todo cite B. Blanchet

To properly talk about analyzing programs, we first need to define what a program is.
So let us start by stating few definitions regarding the syntax:

\begin{defn}[Expression]
    Expression has the following recursive definition:
    \begin{itemize}
        \item $\forall n \in \mathbb{Z}$, n is an expression
        \item a variable $x$ is an expression
        \item $\forall E, F$ expressions, the following are expressions: $E+F$, $E-F$, $E>=F$, $E \dot F$
    \end{itemize}
\end{defn}

\begin{defn}[Statement]
    The following are Statements:
    \begin{itemize}
        \item $end$
        \item $x := E$ for variable $x$ and expression $E$
        \item $if \: E \: goto \: n$ for expression $E$ and $n \in \mathbb{Z}$
        \item $input \: x$ for variable $x$
        \item $print \: E$ for expression $E$
    \end{itemize}
\end{defn}

Then we can define a program as follows:

\begin{defn}[Program]
    Program is a function $Prog$ from integers to Statements.
    Formally:
    \[Prog: \mathbb{Z} \rightarrow Statements\]
\end{defn}

The connection of the formal definition of Program to the common intuition behind program works if we imagine the
integers as the addresses in an address space for the statements. % todo explain better
The state of the running program (process) in a given time $t$ is given by the program counter($pc$), saying which
command is to be executed next and the set of variables in the environment.

To know how the $pc$ and the variables change during the run of the program, we must define the semantics of the
expressions and statements.

\begin{defn}[Expression semantics]
    \xxx{todo}
\end{defn}

\begin{defn} Statement semantics
    \begin{itemize}
        \item $end$ - ends the execution of the process
        \item $x := E$ - sets value of variable $x$ in the environment to the result of $E$
        \item $if \: E \: goto \: n$ - sets the $pc$ to $n$ if the result of $E$ is non-zero
        \item $input \: x$ - sets value of variable $x$ in the environment to the user input
        \item $print \: E$ - adds result of $E$ to the user output
    \end{itemize}
\end{defn}

For a given program and user input, the process goes over a sequence of states.
We call such sequence of states a \textit{trace}.
Since the trace depends on the user input, the semantics of the program is given by the set of traces, rather than
a single trace.

% todo approximation


\section{Galois Connections} %=========================================================================================%

Let us start by the definition:

\begin{defn}[Galois Connection]
    Let $L_1$ (with ordering $\leq _1$) and $L_2$ (with ordering $\leq _2$) be Lattices. % todo galois connections are usually defined on just posets
    Also, let $\alpha: L_1 \rightarrow L_2$ and $\gamma: L_2 \rightarrow L_1$.
    Then the tuple $(\alpha, \gamma)$ is a Galois Connection, if:
    \[ \forall x \in L_1, \: \forall y \in L_2: \: \alpha(x) \leq_2 y \leftrightarrow x \leq_1 \gamma(y)\]
\end{defn}

So Galois Connection is basically a pair of functions connecting the two Lattices.
We call the first lattice ($L_1$) the \textbf{concrete lattice} and the second lattice ($L_2$) the \textbf{abstract lattice}.
Then the function $\alpha$ is called the \textbf{abstraction} and $\gamma$ is the \textbf{concretization}.

In the context of abstract interpretation the concrete lattice is \xxx{todo}

\subsection*{Examples of Galois Connections}
\begin{enumerate}
    \item Approximating real numbers with signs and zero:

    The concrete lattice is $\powerset{\mathbb{R}}$ and the abstract lattice is $\powerset{\{+, -, 0\}}$ (ordered by % todo define znaceni powerset
    inclusion).
    The elements of abstract lattice say what signs can the corresponding element of concrete lattice have.
    For example the set $\{+, 0\}$ represents a non-negative number and $\{+, -\}$ represents a non-zero number in the
    concrete lattice.

    The definition of abstraction function is as follows:
    \begin{gather*}
        \alpha(C) =\\
        \{+ \: if \: C \: contains \: positive \: number\} \: \cup\\
        \{- \: if \: C \: contains \: positive \: number\} \: \cup\\
        \{0 \: if \: C \: contains \: zero\}\\
    \end{gather*}

    And the definition of concretization function is defined:
    \begin{gather*}
        \gamma(A) =\\
        (-\infty, 0) \: if - \in A \: \cup\\
        {0} \: if \: 0 \in A \: \cup\\
        (0, \infty) \: if + \in A \: \\
    \end{gather*}
    % todo show that the conditions for galois connection hold

    \item Boolean algebra with uncertainty

    The concrete lattice is $\powerset{\{True, False\}}$, the abstract lattice is $\{True, False, None\}$.
    Note that $None$ means We do not know. % todo add quotes to "we do not know"

    Then definition of the abstraction is straightforward:
    \begin{gather*}
        \alpha(\{True\}) = True\\
        \alpha(\{False\}) = False\\
        \alpha(\{True, False\}) = None
    \end{gather*}

    And the definition of concretization:
    \begin{gather*}
        \gamma(True) = \{True\}\\
        \gamma(False) = \{False\}\\
        \gamma(None) = \{True, False\}
    \end{gather*}
\end{enumerate}

\xxx{todo anything else?}


\section{The method} %=================================================================================================%

In the previous parts of this chapter, we defined Lattices.
We defined the concrete lattice - the normal world where computer runs.
We also defined the abstract lattice - the world where the analysis takes place.
Then we created a semantics of the statements and the expressions in the concrete lattice.
Finally, we connected the two worlds - concrete and abstract lattice - with Galois Connection, which allows us to
traverse between the two.

What we are still missing is the semantics of the statements and expressions in the abstract lattice.
This is where we finally use the fact that the connection between the concrete and abstract lattice is a Galois
Connection.
We show that the abstract semantics can be derived from the semantics of the concrete lattice and the Galois Connection,
which is the last piece of the Abstract Interpretation puzzle.
We first define the abstract semantics of values, operators and environment variables.
Then we move to the expressions and statements.

\begin{itemize}
    \item \textbf{Values}

    This is the simplest case, since the abstract semantics of $n$ from concrete lattice is just $\alpha(n)$.

    \item \textbf{Operators}

    The abstract semantics of the operator $op$ will be (for $a$ and $b$ from abstract lattice):
    \[a \: op \: b = \alpha(\gamma(a) \: op \: \gamma(b))\]
    So we concretize both the elements from the abstract lattice, then apply the operation $op$ and abstract the result
    back.
    This seems intuitive but why is it the thing we want?


    \item \textbf{Environment Variables}
    \item \textbf{Expressions}
    \item \textbf{Statements}
\end{itemize}

\section*{Summary}
\addcontentsline{toc}{section}{Summary}