\chapter{Putting it all together} % TODO maybe change the name later :)

% TODO change 'As the name of this chapter' if you change the name of the chapter
As the name of this chapter suggests, now we put the knowledge from the previous chapters together.
We build the Abstract Interpretation framework for data manipulation programs.
It involves defining the concrete and abstract lattice and the galois connection between.

Since we are mostly focusing on Pandas in Python, we assume Python environment with Pandas, specifically:

\begin{itemize}
    \item Python syntax
    \item Standard Python data types - int, float, string, list, dictionary, tuple
    \item Pandas is imported via \verb|import pandas as pd| statement
\end{itemize}

We also assume, unlike the Pandas, that Series are homogenous and Dataframes have homogenous columns.
This also implies that each column of a Dataframe has an associated type.

Given these assumptions, we can define a Dataframe Structure:

\begin{defn}[Dataframe Structure]
    For a Dataframe $Df$, its \textbf{Dataframe} Structure is $DS(Df) = \{(Col.name, Col.type) \: for \: each \: column \: in \: Df\}$
\end{defn}

Also, we define a Series Structure:

\begin{defn}[Series Structure]
    For a Series $Sr$, its \textbf{Series Structure} is $SS(Sr) = (Sr.name, Sr.type)$
\end{defn}


\section{The concrete lattice}

The concrete lattice should correspond with the reality.
Since the variables of our program are Dataframes and Series, we can imagine the set of all possible Dataframes and
Series (with every finite number of rows/columns and all possible values).
Then we define the concrete lattice as the power set of this set with the inclusion being the ordering. % todo chaotic
To formalize this:

\begin{defn}[The concrete lattice]

    Let $C = \{\forall df \: Dataframe: df\} \cup \{\forall sr \: Series: sr\}$.
    Then the concrete lattice is $L_c = (\powerset{C}, \subseteq)$
\end{defn}


\section{The abstract lattice}

The abstract lattice can be chosen by us depending on how much we want to abstract the values.
We would like the abstraction to be actually useful in practice.
What does this mean?
In the Abstract Interpretation, whenever we should get a value from the user, we approximate it by the supremum of our
lattice.
This is usually done when we do not know anything about the input, since it is the most precise approximation that is
still sound.
However, we can do something smarter.
We will create and use the assumption that whenever the user inputs a Dataframe, the Column Structure of that Dataframe
is known in advance.
This is not very strong assumption in practice given the fact that the structure of the dataframe is usually known
during the process of writing the program anyway - otherwise we would not be able to write the program at all.

So the abstract lattice is built from the Dataframe Structures and Series Structures.
We take the set of all possible Dataframe Structures and Series Structures.
Then the abstract lattice is the power set of that set with the inclusion being the ordering.
We again formalize this:

\begin{defn}[The abstract lattice]

    Let $A = \{\forall df\: Dataframe: DS(df)\} \cup \{\forall sr \: Series: SS(sr)\}$.
    Then the abstract lattice is $L_a = (\powerset{A}, \subseteq)$ % todo prettier
\end{defn}

\section{The Galois Connection}

To create a Galois Connection we need an abstraction function and a concretization function.

In the abstraction function, we start with a set of Dataframes and Series, and we want a set of Dataframe Structures and
Series Structures.
The most natural way to define such function is to take the set of Dataframe Structures (Series Structures) of the
Dataframes (Series) from the input.
Formally:

\begin{defn}[Abstraction function]
    \begin{gather*}
        \forall X \in L_c \\
        X_{df} = \{df \in X: \: df \: is \: Dataframe\} \\
        X_{sr} = \{sr \in X: \: sr \: is \: Series\} \\
        \alpha(X) = \{DS(df) \forall df \in X_{df}\} \cup \{SS(sr) \forall sr \in X_{sr})\}
    \end{gather*}
\end{defn}

Then we need the Concretization function.
We will define it analogously.
We have a set of Dataframe Structures and Series Structures on the input and want a set of Dataframes and Series
on the output.
So we just take all possible Dataframes (Series) with the given Dataframe (Series) Structure.

\begin{defn}[Concretization function]
    \begin{gather*}
        \forall X \in L_a \\
        X_{df} = \{df \in X: \: df \: is \: Dataframe Structure\} \\
        X_{sr} = \{sr \in X: \: sr \: is \: Series Structure\} \\
        \alpha(X) =
        \bigcup_{dfs \in X_{df}}  \{df: df \: is \: Dataframe \land DS(df) = dfs\}
        \cup \\
        \bigcup_{srs \in X_{sr}} \{sr: sr \: is \: Series \land SS(sr) = srs\}
    \end{gather*}
\end{defn}


\section{Operations}

\section{Adding other types}

\section{Final proposal}

\section{Limitations}


\section*{Summary}
\addcontentsline{toc}{section}{Summary}