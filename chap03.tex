\chapter{Putting it all together} % TODO maybe change the name later :)

% TODO change 'As the name of this chapter' if you change the name of the chapter
As the name of this chapter suggests, now we put the knowledge from the previous chapters together.
We build the Abstract Interpretation framework for data manipulation programs.
It involves defining the concrete and abstract lattice and the galois connection between.

Since we are mostly focusing on Pandas in Python, we assume Python environment with Pandas, specifically:

\begin{itemize}
    \item Python syntax
    \item Standard Python data types - int, float, string, list, dictionary, tuple
    \item Pandas is imported via \verb|import pandas as pd| statement
\end{itemize}

We also assume, unlike the Pandas, that Series are homogenous and Dataframes have homogenous columns.
This also implies that each column of a Dataframe has an associated type.

Given these assumptions, we can define a Dataframe Structure:

\begin{defn}[Dataframe Structure]
    For a Dataframe $Df$, its \textbf{Dataframe} Structure is $DS(Df) = \{(Col.name, Col.type) \: for \: each \: column \: in \: Df\}$
\end{defn}

Also, we define a Series Structure:

\begin{defn}[Series Structure]
    For a Series $Sr$, its \textbf{Series Structure} is $SS(Sr) = (Sr.name, Sr.type)$
\end{defn}


\section{The concrete lattice}

The concrete lattice should correspond with the reality.
Since the variables of our program are Dataframes and Series, we can imagine the set of all possible Dataframes and
Series (with every finite number of rows/columns and all possible values).
Then we define the concrete lattice as the power set of this set with the inclusion being the ordering. % todo chaotic
To formalize this:

\begin{defn}[The concrete lattice]

    Let $C = \{\forall df \: Dataframe: df\} \cup \{\forall sr \: Series: sr\}$.
    Then the concrete lattice is $L_c = (\powerset{C}, \subseteq)$
\end{defn}


\section{The abstract lattice}

The abstract lattice can be chosen by us depending on how much we want to abstract the values.
We would like the abstraction to be actually useful in practice.
What does this mean?
In the Abstract Interpretation, whenever we should get a value from the user, we approximate it by the supremum of our
lattice.
This is usually done when we do not know anything about the input, since it is the most precise approximation that is
still sound.
However, we can do something smarter.
We will create and use the assumption that whenever the user inputs a Dataframe, the Column Structure of that Dataframe
is known in advance.
This is not very strong assumption in practice given the fact that the structure of the dataframe is usually known
during the process of writing the program anyway - otherwise we would not be able to write the program at all.

So the abstract lattice is built from the Dataframe Structures and Series Structures.
We take the set of all possible Dataframe Structures and Series Structures.
Then the abstract lattice is the power set of that set with the inclusion being the ordering.
We again formalize this:

\begin{defn}[The abstract lattice]

    Let $A = \{\forall df\: Dataframe: DS(df)\} \cup \{\forall sr \: Series: SS(sr)\}$.
    Then the abstract lattice is $L_a = (\powerset{A}, \subseteq)$ % todo prettier
\end{defn}

\section{The Galois Connection}

To create a Galois Connection we need an abstraction function and a concretization function.

In the abstraction function, we start with a set of Dataframes and Series, and we want a set of Dataframe Structures and
Series Structures.
The most natural way to define such function is to take the set of Dataframe Structures (Series Structures) of the
Dataframes (Series) from the input.
Formally:

\begin{defn}[Abstraction function]
    \begin{gather*}
        \forall X \in L_c \\
        X_{df} = \{df \in X: \: df \: is \: Dataframe\} \\
        X_{sr} = \{sr \in X: \: sr \: is \: Series\} \\
        \alpha(X) = \{DS(df) \forall df \in X_{df}\} \cup \{SS(sr) \forall sr \in X_{sr})\}
    \end{gather*}
\end{defn}

Then we need the Concretization function.
We will define it analogously.
We have a set of Dataframe Structures and Series Structures on the input and want a set of Dataframes and Series
on the output.
So we just take all possible Dataframes (Series) with the given Dataframe (Series) Structure.

\begin{defn}[Concretization function]
    \begin{gather*}
        \forall X \in L_a \\
        X_{df} = \{df \in X: \: df \: is \: Dataframe Structure\} \\
        X_{sr} = \{sr \in X: \: sr \: is \: Series Structure\} \\
        \alpha(X) =
        \bigcup_{dfs \in X_{df}}  \{df: df \: is \: Dataframe \land DS(df) = dfs\}
        \cup \\
        \bigcup_{srs \in X_{sr}} \{sr: sr \: is \: Series \land SS(sr) = srs\}
    \end{gather*}
\end{defn}

\xxx{TODO prove that this is a galois connection}

\section{Abstract Operations}

In the first chapter we mentioned that the abstract semantics can be systematically derived from the galois connection
and the concrete semantics.
However, it is often not the best way to get to the abstract semantics.
We do an alternative approach.
We define the operations ourselves, since it is a very intuitive process. % todo weird :)
We do not define all the operations that we introduced in the previous chapter, we take a subset of them and left the
rest to the reader as an exercise.

We also define the operations rather on the single Dataframe (Series) Structures rather than on the sets, since it is
easier to understand.
It can then be extended to the set variants in a straightforward way. \xxx{TODO explain}

\begin{itemize}
    \item SELECT

    The first operation we will abstract is a simple SELECT\@.
    We are abstracting selection of a subset of columns given their names.
    This is easy: We take our Dataframe Structure and remove all columns that do not have the names in the selection.
    \begin{example}

        Input: DataFrameStructure(column1: int, column2, string, column3: bool), select([column1, column3])

        Output: DataFrameStructure(column1: int, column3: bool)
    \end{example}
    In a real analysis we should check that all column name specified in select exist in the DataFrameStructure and
    announce an error if the opposite is true.

    \item WHERE

    The WHERE operation has the nice property that it does not change the Dataframe Structure.
    So we just return the input DataframeStructure.
    In a real analysis we should also check that the column referenced in the predicate exists in the DataFrameStructure
    and the comparison happens between compatible types - we should probably announce an error if we are trying to compare
    a number to a string.

    \item JOIN (merge)

    The JOIN is more interesting.
    The input is two DataframeStructures, type of join and related column names.
    The output should be the DataframeStructure of the joined Dataframe.

    \item GROUP BY



    \item \xxx{TODO add some vectorized operations too}


\end{itemize}



\section{Adding other types}

So far, our framework only works with the Dataframe and Series types.
Usually, however, these are not the only types in our program.
We should also be able to work with normal ints, strings, lists, dictionaries or tuples.

We will also abstract these types but in a slightly different way.

\section{Final proposal}

\xxx{TODO merge the "adding other types" together with the Dataframe/Series framework}

\section{Limitations}

\xxx{
TODO mention the limitations of the analysis:
pivoting, transpose,
spreading of an unknown value
}

\section*{Summary}
\addcontentsline{toc}{section}{Summary}